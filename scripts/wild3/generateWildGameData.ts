import fs from "node:fs/promises";
import prettier from "prettier";
import { z } from "zod";
import type { Species } from "../../src/rngTools";
import { species as allSpecies } from "../../src/types/species";
import { genderRatioBySpecies } from "../../src/types/gender";
import { Wild3GameDataJSON } from "../../src/rngToolsUi/gen3/wild/wild3GameData";
import { doesSpeciesHaveType } from "./pokemonTypes";

// https://github.com/pret/pokeemerald/blob/master/src/data/wild_encounters.json
import emerald_wild_encounters from "./emerald_wild_encounters.json";

export const writeFile = async (
  destinationFile: string,
  jsonData: Wild3GameDataJSON,
) => {
  const str = `
// DO NOT MANUALLY EDIT THIS FILE
// This file was generated by running "bun run build:wild3".

import type { Wild3GameDataJSON } from "../rngToolsUi/gen3/wild/wild3GameData";

const wild3_game_data: Wild3GameDataJSON = ${JSON.stringify(jsonData)};

export default wild3_game_data;
`;
  const formattedStr = await prettier.format(str, { parser: "typescript" });
  await fs.writeFile(destinationFile, formattedStr);
};

export const generateEmeraldWildGameData = async () => {
  const jsonData: Wild3GameDataJSON = {
    encounter_tables: [],
  };

  const formatSpecies = (speciesName: string | Species): string => {
    return speciesName
      .toLowerCase()
      .replace("species_", "")
      .replace(/[^a-z0-9]/g, "");
  };

  const jsonNameToSpecies = (speciesJsonName: string): Species => {
    const species = formattedSpeciesToSpecies.get(
      formatSpecies(speciesJsonName),
    );
    if (species === undefined)
      throw new Error(`Unknown species: ${speciesJsonName}`);
    return species;
  };

  const formattedSpeciesToSpecies = new Map<string, Species>();

  allSpecies.forEach((species) => {
    formattedSpeciesToSpecies.set(formatSpecies(species), species);
  });

  const EncounterSchema = z.object({
    map: z.string().optional(),
    base_label: z.string().optional(),
    land_mons: z
      .object({
        mons: z
          .object({
            min_level: z.number(),
            max_level: z.number(),
            species: z.string(),
          })
          .array(),
      })
      .optional(),
  });

  emerald_wild_encounters.wild_encounter_groups.forEach((grp) => {
    grp.encounters.forEach((raw_enc) => {
      const enc = EncounterSchema.parse(raw_enc);

      if (!enc.map) {
        return;
      }

      if (
        enc.map === "MAP_ALTERING_CAVE" &&
        enc.base_label !== "gAlteringCave1"
      ) {
        return;
      }

      if (enc.land_mons) {
        const slots = enc.land_mons.mons.map((landMon, encounterSlotIdx) => {
          const species = jsonNameToSpecies(landMon.species);

          return {
            min_level: landMon.min_level,
            max_level: landMon.max_level,
            species,
            gender_ratio: genderRatioBySpecies[species],
            is_electric_type: doesSpeciesHaveType(3, species, "Electric"),
            is_steel_type: doesSpeciesHaveType(3, species, "Steel"),
          };
        });
        jsonData.encounter_tables.push({
          map_id: enc.map,
          encounter_type: "Land",
          slots,
        });
      }
    });
  });

  await writeFile("./src/__generated__/emerald_wild3_game_data.ts", jsonData);
};

await generateEmeraldWildGameData();
