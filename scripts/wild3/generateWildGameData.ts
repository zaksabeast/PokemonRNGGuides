import type {
  Species,
  EncounterSlot,
  Wild3EncounterSlotInfo,
  Wild3EncounterTable,
} from "../../src/rngTools";
import { species as allSpecies, species } from "../../src/types/species";
import { genderRatioBySpecies } from "../../src/types/gender";
import { encounterSlots } from "../../src/types/encounterSlots";
import { Wild3GameDataJSON } from "../../src/rngToolsUi/gen3/wild/wild3GameData";
import fs from "node:fs/promises";
import { doesSpeciesHaveType } from "./pokemonTypes";

// https://github.com/pret/pokeemerald/blob/master/src/data/wild_encounters.json
import emerald_wild_encounters from "./emerald_wild_encounters.json";

export const writeFile = async (
  destinationFile: string,
  jsonData: Wild3GameDataJSON,
) => {
  const str = `
// DO NOT MANUALLY EDIT THIS FILE
// This file was generated by running "bun run build:wild3".

import type { Wild3GameDataJSON } from "./wild3GameData";

const wild3_game_data: Wild3GameDataJSON = ${JSON.stringify(jsonData)};

export default wild3_game_data;
`;
  await fs.writeFile(destinationFile, str);
};

export const generateEmeraldWildGameData = async () => {
  const jsonData: Wild3GameDataJSON = {
    encounter_tables: [],
  };

  const formatSpecies = (speciesName: string | Species): string => {
    return speciesName
      .toLowerCase()
      .replace("species_", "")
      .replace(/[^a-z0-9]/g, "");
  };
  const jsonNameToSpecies = (speciesName: string): Species | undefined => {
    return formattedSpeciesToSpecies.get(formatSpecies(speciesName));
  };

  const formattedSpeciesToSpecies = new Map<string, Species>();

  allSpecies.forEach((species) => {
    formattedSpeciesToSpecies.set(formatSpecies(species), species);
  });

  emerald_wild_encounters.wild_encounter_groups.forEach((grp) => {
    grp.encounters.forEach((raw_enc) => {
      const enc = raw_enc as {
        map?: string;
        base_label?: string;
        land_mons?: {
          mons: {
            min_level: number;
            max_level: number;
            species: string;
          }[];
        };
      };

      if (!enc.map) {
        return;
      }

      if (
        enc.map === "MAP_ALTERING_CAVE" &&
        enc.base_label !== "gAlteringCave1"
      ) {
        return;
      }

      if (enc.land_mons) {
        const slots = enc.land_mons.mons.map((landMon, encounterSlotIdx) => {
          const species = jsonNameToSpecies(landMon.species);
          if (!species) throw `Unknown species: ${landMon.species}`;

          return {
            min_level: landMon.min_level,
            max_level: landMon.max_level,
            species,
            gender_ratio: genderRatioBySpecies[species],
            is_electric_type: doesSpeciesHaveType(3, species, "Electric"),
            is_steel_type: doesSpeciesHaveType(3, species, "Steel"),
          };
        });
        jsonData.encounter_tables.push({
          map_id: enc.map,
          encounter_type: "Land",
          slots,
        });
      }
    });
  });
  /*
  emerald_wild_encounters.
  
pub struct Wild3EncounterSlotInfo {
    pub min_level:u8,
    pub max_level:u8,
    pub species:species,
    pub gender_ratio:GenderRatio,
    pub is_electric_type:bool,
    pub is_steel_type:bool,
}

pub struct Wild3EncounterTable {
    pub map_id:String,
    pub encounter_rate:u8,
    pub slots:Vec<Wild3EncounterSlotInfo>,
}
*/

  await writeFile(
    "./src/rngToolsUi/gen3/wild/emerald_wild3_game_data.ts",
    jsonData,
  );
};

await generateEmeraldWildGameData();

/*

{
          "map": "MAP_ROUTE101",
          "base_label": "gRoute101",
          "land_mons": {
            "encounter_rate": 20,
            "mons": [
              {
                "min_level": 2,
                "max_level": 2,
                "species": "SPECIES_WURMPLE"
              },
            ]
          }
        },


*/
