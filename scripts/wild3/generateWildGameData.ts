import fs from "node:fs/promises";
import prettier from "prettier";
import { z } from "zod";
import type { Gen3EncounterType, Species } from "../../src/rngTools";
import { species as allSpecies } from "../../src/types/species";
import { genderRatioBySpecies } from "../../src/types/gender";
import { Wild3GameDataJSON } from "../../src/rngToolsUi/gen3/wild/wild3GameData";
import { doesSpeciesHaveType } from "./pokemonTypes";

// https://github.com/pret/pokeemerald/blob/master/src/data/wild_encounters.json
import emerald_wild_encounters from "./emerald_wild_encounters.json";

export const writeFile = async (
  destinationFile: string,
  jsonData: Wild3GameDataJSON,
) => {
  const str = `
// DO NOT MANUALLY EDIT THIS FILE
// This file was generated by running "bun run build:wild3".

import type { Wild3GameDataJSON } from "../rngToolsUi/gen3/wild/wild3GameData";

const wild3_game_data: Wild3GameDataJSON = ${JSON.stringify(jsonData)};

export default wild3_game_data;
`;
  const formattedStr = await prettier.format(str, { parser: "typescript" });
  await fs.writeFile(destinationFile, formattedStr);
};

export const generateEmeraldWildGameData = async () => {
  const jsonData: Wild3GameDataJSON = {
    encounter_tables: [],
  };

  const formatSpecies = (speciesName: string | Species): string => {
    return speciesName
      .toLowerCase()
      .replace("species_", "")
      .replace(/[^a-z0-9]/g, "");
  };

  const jsonNameToSpecies = (speciesJsonName: string): Species => {
    const species = formattedSpeciesToSpecies.get(
      formatSpecies(speciesJsonName),
    );
    if (species === undefined)
      throw new Error(`Unknown species: ${speciesJsonName}`);
    return species;
  };

  const formattedSpeciesToSpecies = new Map<string, Species>();

  allSpecies.forEach((species) => {
    formattedSpeciesToSpecies.set(formatSpecies(species), species);
  });

  const encounterTypeMons = z
    .object({
      mons: z.array(
        z.object({
          species: z.string(),
          min_level: z.number(),
          max_level: z.number(),
        }),
      ),
    })
    .optional();

  const EncounterSchema = z.object({
    map: z.string().optional(),
    base_label: z.string().optional(),
    land_mons: encounterTypeMons,
    water_mons: encounterTypeMons,
    fishing_mons: encounterTypeMons,
  });

  emerald_wild_encounters.wild_encounter_groups.forEach((grp) => {
    grp.encounters.forEach((raw_enc) => {
      const enc = EncounterSchema.parse(raw_enc);

      if (!enc.map) {
        return;
      }

      if (
        enc.map === "MAP_ALTERING_CAVE" &&
        enc.base_label !== "gAlteringCave1"
      ) {
        return;
      }

      const handleEncounterType = (
        encounterType: Gen3EncounterType,
        mons:
          | { species: string; min_level: number; max_level: number }[]
          | undefined,
      ) => {
        if (!mons || mons.length === 0) {
          return;
        }

        const slots = mons.map((landMon, encounterSlotIdx) => {
          const species = jsonNameToSpecies(landMon.species);

          return {
            min_level: landMon.min_level,
            max_level: landMon.max_level,
            species,
            gender_ratio: genderRatioBySpecies[species],
            is_electric_type: doesSpeciesHaveType(3, species, "Electric"),
            is_steel_type: doesSpeciesHaveType(3, species, "Steel"),
          };
        });

        jsonData.encounter_tables.push({
          map_id: enc.map,
          encounter_type: encounterType,
          slots,
        });
      };

      handleEncounterType("Land", enc.land_mons?.mons);
      handleEncounterType("Water", enc.water_mons?.mons);
      handleEncounterType("OldRod", enc.fishing_mons?.mons.slice(0, 2));
      handleEncounterType("GoodRod", enc.fishing_mons?.mons.slice(2, 5));
      handleEncounterType("SuperRod", enc.fishing_mons?.mons.slice(5, 10));
    });
  });

  await writeFile("./src/__generated__/emerald_wild3_game_data.ts", jsonData);
};

await generateEmeraldWildGameData();
